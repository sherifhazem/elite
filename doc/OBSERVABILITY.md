# Observability System — ELITE Project

## 1. Purpose of This Document
This document defines the centralized and simplified observability system used in the ELITE project.

It exists to ensure that:
- Monitoring remains centralized, predictable, and maintainable.
- No logging logic appears inside routes, services, modules, or JS files.
- AI agents understand exactly how observability works and how to extend or maintain it.
- The system avoids unnecessary complexity and prevents architectural drift.
- All observability behavior remains documented, explicit, and stable.

---

## 2. Observability Philosophy
The ELITE project uses a **minimalist, centralized, non-intrusive** observability model.

This means:
1. Logging is activated only at one single point (`app/__init__.py`).
2. No module or service interacts directly with the logging system.
3. No distributed JS or request-level instrumentation exists outside the central middleware.
4. The system tracks what is useful — and nothing more.
5. Logs remain local and stored as JSON files.

---

## 3. Observability Components
The observability layer is intentionally compact and now spans the following files:

### 3.1 `app/logging/logger.py`
Purpose:
- Provide centralized logging that unifies the **root**, **flask.app**, and **werkzeug** loggers.
- Configure both console and JSON file handlers with shared request-aware formatting.

Responsibilities:
- Auto-create and rotate `logs/app.log.json` daily, retaining four days of history.
- Enrich logs with request metadata (path, method, request_id) and user identity when available.
- Guard handler attachment to remain idempotent on reloads.

### 3.2 `app/core/central_middleware.py`
Purpose:
- Middleware-based request tracking.

Responsibilities:
- Generate a `request_id` for every incoming request and store it in `g.request_id`.
- Add the `request_id` to every response header under `X-Request-ID`.
- Log request start and completion, including processing duration, through the centralized logger.
- Log unhandled errors centrally.

### 3.3 `app/__init__.py` (Activation Point)
Purpose:
- Activates logging and middleware.

Responsibilities:
- Call `initialize_logging(app)` from `app/logging/logger.py` as part of the application factory.
- Register the middleware inside `create_app()` using Flask hooks.
- Ensure all modules automatically follow the global logging policy.

There is **no logging code** inside:
- Routes
- Services
- Modules
- Templates
- Static files
- Tooling scripts

---

## 4. Log Format
All logs generated by the system follow the unified JSON structure with request-aware enrichment:

```json
{
  "timestamp": "2025-01-01T12:00:00Z",
  "level": "INFO",
  "message": "request_completed",
  "file": "central_middleware.py",
  "function": "end_request_logging",
  "line": 45,
  "request_id": "unique-id",
  "user_id": 42,
  "path": "/current/request/path",
  "method": "GET"
}
```

Rules:
- JSON only (one JSON object per line) for file output while console remains human-friendly but shares the same fields.
- Request metadata is included automatically when a request context exists.
- Logs flow through the centralized formatter regardless of origin logger.

---

## 5. Runtime Logging Behavior
### 5.1 Request Lifecycle Logging
Each request automatically logs:
- `request_started` when the request begins.
- `request_completed` when the response is ready, including `duration_ms`.
- HTTP method and path for every lifecycle log.
- The generated `request_id`, also returned in the `X-Request-ID` response header.

### 5.2 Error Logging
Unhandled errors automatically produce:
- Error-level logs containing the request path, method, `request_id`, and `duration_ms` when available.
- A `details` payload including the HTTP status code and error message.
- A JSON error response carrying the same `request_id` in both the body and the `X-Request-ID` header.

### 5.3 Location of Logs and Rotation
- All observability output goes to `/logs/app.log.json` with daily rotation (`app.log.json.YYYY-MM-DD`) and 4-day retention.
- The log directory is created automatically if it does not exist.

### 5.4 No Additional Logging Allowed
To avoid complexity:
- Modules must not log.
- Services must not log.
- JS/front-end must not log.
- Routes must not call the logger.

---

## 6. Directory Structure for Observability
```
app/logging/
    logger.py                  # Central logging configuration and formatter

app/core/
    central_middleware.py      # Centralized request tracking middleware
    database.py                # (Unrelated) listed for context

app/__init__.py               # Activation point for the observability system

logs/
    app.log.json              # Central JSON log file (rotated daily)
```

---

## 7. What Is Explicitly NOT Part of the System
The following features are **not** part of the observability system:
- Per-module logging
- Service-level logging
- Distributed JS tracking
- API wrapper instrumentation
- Frontend instrumentation
- Analytics dashboards
- External tools (Sentry / Prometheus / ELK / Loki / Datadog)
- Metrics or event pipelines
- Tracing systems

Any of these require explicit approval before implementation.

---

## 8. Maintenance Rules for AI Agents
When updating or modifying the observability logic, agents must:
1. Modify logging configuration only inside `app/logging/logger.py` (plus `app/__init__.py` for activation).
2. Keep logging centralized and minimal.
3. Avoid adding logging code anywhere else.
4. Preserve the unified JSON log format and rotation rules.
5. Update this file if the log structure or middleware behavior changes.
6. Update `CHANGELOG.md` for every change.

---

## 9. Summary
The ELITE observability layer is intentionally simple, centralized, and non-intrusive. All logging is activated from `app/__init__.py` and implemented only in the core layer. This document must be kept in sync with the actual implementation to guarantee predictable behavior.
